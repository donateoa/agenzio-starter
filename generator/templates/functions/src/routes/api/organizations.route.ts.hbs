import { Router, Response, NextFunction } from 'express';
import * as admin from 'firebase-admin';
import { v4 as uuidv4 } from 'uuid';
import { frontendUrlSecret, resendApiKey, fromEmailSecret } from '../../config';

const router = Router();
const db = admin.firestore();

// Simple auth middleware
const checkAuth = async (req: any, res: Response, next: NextFunction) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const token = authHeader.split('Bearer ')[1];
    const decodedToken = await admin.auth().verifyIdToken(token);
    req.user = decodedToken;
    next();
  } catch (error) {
    console.error('Auth error:', error);
    return res.status(401).json({ error: 'Invalid token' });
  }
};

// Helper to check if user has OWNER access
async function checkOrgOwner(orgId: string, userId: string): Promise<boolean> {
  const rolesSnap = await db.collection('practitionerRoles')
    .where('organizationId', '==', orgId)
    .where('practitionerId', '==', userId)
    .where('roleCode', '==', 'OWNER')
    .limit(1)
    .get();
  return !rolesSnap.empty;
}

// Helper to check if user can manage team
async function canManageTeam(orgId: string, userId: string): Promise<boolean> {
  const rolesSnap = await db.collection('practitionerRoles')
    .where('organizationId', '==', orgId)
    .where('practitionerId', '==', userId)
    .limit(1)
    .get();

  if (rolesSnap.empty) return false;
  const roleCode = rolesSnap.docs[0].data().roleCode;
  return ['OWNER', 'ADMIN', 'SECRETARY'].includes(roleCode);
}

// Helper to check if user has any role in org
async function checkRole(orgId: string, userId: string): Promise<boolean> {
  const rolesSnap = await db.collection('practitionerRoles')
    .where('organizationId', '==', orgId)
    .where('practitionerId', '==', userId)
    .limit(1)
    .get();
  return !rolesSnap.empty;
}

// Simple email sending (requires Resend API)
async function sendEmail(to: string, subject: string, html: string): Promise<void> {
  const apiKey = resendApiKey.value();
  const fromEmail = fromEmailSecret.value();

  if (!apiKey) {
    console.warn('RESEND_API_KEY not configured, skipping email');
    return;
  }

  const response = await fetch('https://api.resend.com/emails', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ from: fromEmail, to, subject, html })
  });

  if (!response.ok) {
    console.error('Failed to send email:', await response.text());
  }
}

// GET / - Get organizations for current user
router.get('/', checkAuth, (async (req: any, res: Response) => {
  try {
    const uid = req.user.uid;
    const email = req.user.email?.toLowerCase();

    // Get roles by UID
    const rolesByUidSnap = await db.collection('practitionerRoles')
      .where('practitionerId', '==', uid)
      .get();

    const roles: any[] = rolesByUidSnap.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Get by email (for pending invitations)
    if (email) {
      const rolesByEmailSnap = await db.collection('practitionerRoles')
        .where('email', '==', email)
        .get();

      rolesByEmailSnap.docs.forEach(doc => {
        if (!roles.some(r => r.id === doc.id)) {
          roles.push({ id: doc.id, ...doc.data() });
        }
      });
    }

    const orgIds = [...new Set(roles.map((r: any) => r.organizationId))];
    if (orgIds.length === 0) return res.json([]);

    // Fetch Organizations
    const orgs: any[] = [];
    for (const orgId of orgIds) {
      const orgDoc = await db.collection('organizations').doc(orgId).get();
      if (orgDoc.exists) {
        const role = roles.find((r: any) => r.organizationId === orgId);
        orgs.push({
          id: orgDoc.id,
          ...orgDoc.data(),
          membershipStatus: role?.status || 'ACCEPTED',
          roleCode: role?.roleCode || 'VIEWER'
        });
      }
    }

    return res.json(orgs);
  } catch (error: any) {
    console.error('Get User Organizations Error:', error);
    return res.status(500).json({ error: 'Failed to fetch organizations' });
  }
}) as any);

// GET /:id - Get specific organization
router.get('/:id', checkAuth, (async (req: any, res: Response) => {
  try {
    const uid = req.user.uid;
    const orgId = req.params.id;

    // Verify membership
    const hasAccess = await checkRole(orgId, uid);
    if (!hasAccess) {
      return res.status(403).json({ error: 'Forbidden: You are not a member of this organization' });
    }

    const orgDoc = await db.collection('organizations').doc(orgId).get();
    if (!orgDoc.exists) return res.status(404).json({ error: 'Organization not found' });

    return res.json({ id: orgDoc.id, ...orgDoc.data() });
  } catch (error: any) {
    console.error('Get Organization Error:', error);
    return res.status(500).json({ error: 'Failed to fetch organization' });
  }
}) as any);

// POST / - Create a new organization
router.post('/', checkAuth, (async (req: any, res: Response) => {
  try {
    const uid = req.user.uid;
    const { name, description } = req.body;

    if (!name) {
      return res.status(400).json({ error: 'Organization name is required' });
    }

    const batch = db.batch();

    // Create Organization
    const orgRef = db.collection('organizations').doc();
    const newOrg = {
      resourceType: 'Organization',
      name,
      description: description || '',
      ownerId: uid,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    batch.set(orgRef, newOrg);

    // Create PractitionerRole (OWNER)
    const roleRef = db.collection('practitionerRoles').doc();
    const newRole = {
      resourceType: 'PractitionerRole',
      organizationId: orgRef.id,
      practitionerId: uid,
      organization: { reference: `Organization/${orgRef.id}` },
      practitioner: { reference: `Practitioner/${uid}` },
      roleCode: 'OWNER',
      active: true,
      status: 'ACCEPTED',
      period: { start: new Date().toISOString() }
    };
    batch.set(roleRef, newRole);

    await batch.commit();

    return res.status(201).json({ id: orgRef.id, ...newOrg });
  } catch (error: any) {
    console.error('Create Organization Error:', error);
    return res.status(500).json({ error: 'Failed to create organization' });
  }
}) as any);

// PUT /:id - Update organization
router.put('/:id', checkAuth, (async (req: any, res: Response) => {
  try {
    const uid = req.user.uid;
    const orgId = req.params.id;
    const { name, description } = req.body;

    if (!name) return res.status(400).json({ error: 'Name is required' });

    // Verify ownership
    if (!(await checkOrgOwner(orgId, uid))) {
      return res.status(403).json({ error: 'Forbidden: Only owner can update organization' });
    }

    const orgRef = db.collection('organizations').doc(orgId);
    await orgRef.update({
      name,
      description: description || '',
      updatedAt: new Date().toISOString()
    });

    const updatedDoc = await orgRef.get();
    return res.json({ id: updatedDoc.id, ...updatedDoc.data() });
  } catch (error: any) {
    console.error('Update Organization Error:', error);
    return res.status(500).json({ error: 'Failed to update organization' });
  }
}) as any);

// DELETE /:id - Delete organization
router.delete('/:id', checkAuth, (async (req: any, res: Response) => {
  try {
    const uid = req.user.uid;
    const orgId = req.params.id;

    // Verify ownership
    if (!(await checkOrgOwner(orgId, uid))) {
      return res.status(403).json({ error: 'Forbidden: Only owner can delete organization' });
    }

{{#if includeStripe}}
    // Check for active subscription
    const orgRef = db.collection('organizations').doc(orgId);
    const orgDoc = await orgRef.get();
    const orgData = orgDoc.data();
    const subStatus = orgData?.subscription?.status;
    if (subStatus === 'active' || subStatus === 'trialing') {
      return res.status(400).json({
        error: 'Active subscription detected',
        message: 'Cannot delete organization with active subscription.'
      });
    }
{{/if}}

    const batch = db.batch();

    // Delete PractitionerRoles
    const rolesSnap = await db.collection('practitionerRoles').where('organizationId', '==', orgId).get();
    rolesSnap.docs.forEach(r => batch.delete(r.ref));

    // Delete the Organization
    batch.delete(db.collection('organizations').doc(orgId));

    await batch.commit();

    return res.json({ success: true, message: 'Organization deleted' });
  } catch (error: any) {
    console.error('Delete Organization Error:', error);
    return res.status(500).json({ error: 'Failed to delete organization' });
  }
}) as any);

// GET /:orgId/members - Get all members
router.get('/:orgId/members', checkAuth, (async (req: any, res: Response) => {
  try {
    const { orgId } = req.params;
    const userId = req.user.uid;

    const hasAccess = await checkRole(orgId, userId);
    if (!hasAccess) {
      return res.status(403).json({ error: 'Forbidden: No access to this organization' });
    }

    const rolesSnap = await db.collection('practitionerRoles')
      .where('organizationId', '==', orgId)
      .get();

    const members = await Promise.all(rolesSnap.docs.map(async doc => {
      const roleData = doc.data();
      const pId = roleData.practitionerId;

      let userData = null;
      if (pId && !pId.startsWith('temp-')) {
        const userDoc = await db.collection('users').doc(pId).get();
        userData = userDoc.exists ? userDoc.data() : null;
      }

      return {
        id: doc.id,
        ...roleData,
        displayName: userData?.displayName || roleData.email || 'User',
        photoURL: userData?.photoURL || null,
        email: roleData.email || userData?.email || null
      };
    }));

    return res.json(members);
  } catch (error: any) {
    console.error('Get Org Members Error:', error);
    return res.status(500).json({ error: 'Failed to fetch organization members' });
  }
}) as any);

// POST /:orgId/invites - Invite a user
router.post('/:orgId/invites', checkAuth, (async (req: any, res: Response) => {
  try {
    const { orgId } = req.params;
    const userId = req.user.uid;
    const { email, roleCode } = req.body;

    if (!email) return res.status(400).json({ error: 'Email is required' });

    if (!(await canManageTeam(orgId, userId))) {
      return res.status(403).json({ error: 'Forbidden: Insufficient permissions' });
    }

    const lowerEmail = email.toLowerCase();
    let invitedUserId: string;

    // Try to find existing user
    try {
      const userRecord = await admin.auth().getUserByEmail(lowerEmail);
      invitedUserId = userRecord.uid;
    } catch (e) {
      invitedUserId = `temp-${uuidv4()}`;
    }

    // Check if already a member
    const existingRole = await db.collection('practitionerRoles')
      .where('organizationId', '==', orgId)
      .where('practitionerId', '==', invitedUserId)
      .limit(1)
      .get();

    if (!existingRole.empty) {
      return res.status(400).json({ error: 'User is already a member or invited' });
    }

    // Create the role
    const roleData = {
      resourceType: 'PractitionerRole',
      organizationId: orgId,
      practitionerId: invitedUserId,
      email: lowerEmail,
      organization: { reference: `Organization/${orgId}` },
      practitioner: { reference: `Practitioner/${invitedUserId}` },
      roleCode: roleCode || 'VIEWER',
      active: true,
      status: 'PENDING',
      invitedBy: userId,
      invitedAt: new Date().toISOString()
    };

    const roleRef = await db.collection('practitionerRoles').add(roleData);

    // Send invitation email
    const orgDoc = await db.collection('organizations').doc(orgId).get();
    const orgName = orgDoc.data()?.name || 'an organization';
    const frontendUrl = frontendUrlSecret.value() || 'https://{{appName}}.web.app';
    const inviteLink = `${frontendUrl}/invites/accept?orgId=${orgId}&inviteId=${roleRef.id}`;

    await sendEmail(
      email,
      `Invitation to collaborate: ${orgName}`,
      `<p>You have been invited to collaborate with <strong>${orgName}</strong>.</p>
       <p>Click here to accept: <a href="${inviteLink}">${inviteLink}</a></p>`
    );

    return res.status(201).json({ id: roleRef.id, ...roleData });
  } catch (error: any) {
    console.error('Invite Org Member Error:', error);
    return res.status(500).json({ error: 'Failed to invite member' });
  }
}) as any);

// DELETE /:orgId/members/:roleId - Remove a member
router.delete('/:orgId/members/:roleId', checkAuth, (async (req: any, res: Response) => {
  try {
    const { orgId, roleId } = req.params;
    const userId = req.user.uid;

    if (!(await canManageTeam(orgId, userId))) {
      return res.status(403).json({ error: 'Forbidden: Insufficient permissions' });
    }

    const roleRef = db.collection('practitionerRoles').doc(roleId);
    const roleDoc = await roleRef.get();

    if (!roleDoc.exists) return res.status(404).json({ error: 'Member not found' });

    const roleData = roleDoc.data();
    if (roleData?.organizationId !== orgId) {
      return res.status(400).json({ error: 'Mismatched organization ID' });
    }

    if (roleData?.practitionerId === userId && roleData?.roleCode === 'OWNER') {
      return res.status(400).json({ error: 'Cannot remove yourself as Owner' });
    }

    await roleRef.delete();

    return res.json({ success: true, message: 'Member removed' });
  } catch (error: any) {
    console.error('Remove Org Member Error:', error);
    return res.status(500).json({ error: 'Failed to remove member' });
  }
}) as any);

// POST /invites/:inviteId/accept - Accept an invitation
router.post('/invites/:inviteId/accept', checkAuth, (async (req: any, res: Response) => {
  try {
    const { inviteId } = req.params;
    const userId = req.user.uid;
    const userEmail = req.user.email?.toLowerCase();

    const roleRef = db.collection('practitionerRoles').doc(inviteId);
    const roleDoc = await roleRef.get();

    if (!roleDoc.exists) return res.status(404).json({ error: 'Invite not found' });

    const roleData = roleDoc.data();
    const roleEmail = roleData?.email?.toLowerCase();

    if (roleData?.practitionerId !== userId && roleEmail !== userEmail) {
      return res.status(403).json({ error: 'This invite is for another user' });
    }

    await roleRef.update({
      practitionerId: userId,
      status: 'ACCEPTED',
      acceptedAt: new Date().toISOString()
    });

    return res.json({ success: true });
  } catch (error: any) {
    console.error('Accept Org Invite Error:', error);
    return res.status(500).json({ error: 'Failed to accept invite' });
  }
}) as any);

// POST /invites/:inviteId/reject - Reject an invitation
router.post('/invites/:inviteId/reject', checkAuth, (async (req: any, res: Response) => {
  try {
    const { inviteId } = req.params;
    const userEmail = req.user.email?.toLowerCase();

    const roleRef = db.collection('practitionerRoles').doc(inviteId);
    const roleDoc = await roleRef.get();

    if (!roleDoc.exists) return res.status(404).json({ error: 'Invite not found' });

    const roleData = roleDoc.data();
    const roleEmail = roleData?.email?.toLowerCase();

    if (roleEmail !== userEmail) {
      return res.status(403).json({ error: 'This invite is for another user' });
    }

    await roleRef.delete();

    return res.json({ success: true });
  } catch (error: any) {
    console.error('Reject Org Invite Error:', error);
    return res.status(500).json({ error: 'Failed to reject invite' });
  }
}) as any);

export default router;
